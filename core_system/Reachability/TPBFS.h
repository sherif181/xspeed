/*
 * TPBFS.h
 *
 *  Created on: 28-Oct-2016
 *      Author: amit
 */

#ifndef TPBFS_H_
#define TPBFS_H_

#include "reachability.h"

class tpbfs : public reachability{
public:
	/*
		 * Here we also apply Load Balancing algorithm for POST_D computation
		 */
		std::list<symbolic_states::ptr> LoadBalanceAll(std::list<abstractCE::ptr>& ce);

private:

		template_polyhedra::ptr substitute_in_ReachAlgorithm(LoadBalanceData& LoadBalanceDS, int numCoreAvail);

		void parallelLoadBalance_Task(std::vector<LoadBalanceData>& LoadBalanceDS);

		/*void preLoadBalanceReachCompute(ReachabilityParameters& ReachParameters, Dynamics& SystemDynamics,
				supportFunctionProvider::ptr Initial, polytope::ptr invariant, bool isInvariantExist, math::matrix<float>& List_dir_X0,
				math::matrix<float>& List_dir_U, unsigned int& newIteration);*/
		void preLoadBalanceReachCompute(LoadBalanceData& LoadBalanceDS, int numCoresAvail);


		/*
		 * Load Balanced PostD computation:: checking Intersection with guard in parallel
		 */
		void loadBalancedPostD(std::vector<LoadBalanceData_PostD>& loadBalPostD);


		/*
		 * Checking Intersection region within the sfm
		 */
		void intersectionRangeDetection(std::vector<LoadBalanceData_PostD>& loadBalPostD);

		/*
		 * From each Intersected region generated by intersectionRangeDetection() for each guard of each symbolic_state/sfm
		 * template Approximation is performed and returns the polytopes as results
		 */
		void templateApproximation(std::vector<LoadBalanceData_PostD>& loadBalPostD);


		/*
		 * Both 1) and 2) method resulted in same performance as Work-Load for flowpipe computation is uneven
		 * So 3) will aggregrate all flowpipe computation work into one BIG task and will run that in
		 * parallel by multi-core CPU or GPU
		------------- This interface is not in use now.
		 */
			std::list<symbolic_states::ptr> computeParallelLoadBalanceReach(std::list<abstractCE::ptr>& ce_candidates);

};


#endif /* TPBFS_H_ */
